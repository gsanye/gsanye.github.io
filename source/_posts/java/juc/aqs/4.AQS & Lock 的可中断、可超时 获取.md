---
title: 4.AQS & Lock 的可中断、可超时 获取
date: 2025-08-14 07:12:07
tags:
- java
- juc

category:
- java
- juc
- aqs

---

# 可中断获取
## lock Interruptibly
首先查看lock代码的可中断获取

```java

    @Override
    public void lockInterruptibly() throws InterruptedException {
        //AQS模板方法：同步器可中断获取
        sync.acquireInterruptibly(1);
    }
```

## AQS acquireInterruptibly
进行可中断获取

1. 首先进入方法判断是否已经interrupted
2. 尝试获取，如果失败则进入acquire loop中循环尝试获取

```java

    /**
     * exclusive模式获取，如果interrupted则中止并抛出InterruptedException
     */
    public final void acquireInterruptibly(int arg)
            throws InterruptedException {
        //入口判断线程是否中断
        if (Thread.interrupted())
            throw new InterruptedException();
        // 尝试获取，如果失败，则在acquire loop中进行尝试获取
        if (!tryAcquire(arg))
            doAcquireInterruptibly(arg);
    }
```

## doAcquireInterruptibly
可中断获取循环，与普通acquire loop 不同之处在于检查到中断后直接抛出异常

```java

    /**
     * 循环可中断获取
     */
    private void doAcquireInterruptibly(int arg)
        throws InterruptedException {
        final Node node = addWaiter(Node.EXCLUSIVE);
        boolean failed = true;
        try {
            for (;;) {
                final Node p = node.predecessor();
                if (p == head && tryAcquire(arg)) {
                    setHead(node);
                    p.next = null; // help GC
                    failed = false;
                    return;
                }
                if (shouldParkAfterFailedAcquire(p, node) &&
                    parkAndCheckInterrupt())
                    // 检查到中断后，不再设置中断状态，而是直接抛出异常
                    throw new InterruptedException();
            }
        } finally {
            if (failed)
                cancelAcquire(node);
        }
    }
```

# 可超时、中断 获取
## Lock tryLock(time,timeUnit)
尝试在给定时间内获取锁，返回是否获取成功。

返回的三种条件：

1. 当前线程获取锁成功
2. 当前线程被interrupted
3. 已经达到指定时间

```java
    @Override
    public boolean tryLock(long time, TimeUnit unit) throws InterruptedException {
        //AQS模板方法：同步器超时可中断获取
        return sync.tryAcquireNanos(1, unit.toNanos(time));
    }

```

## AQS doAcquireNanos
尝试超时获取

1. 方法入口判断是否interrupted
2. 尝试获取，如果失败则进入acquire loop中循环尝试获取

```java

    /**
     * 超时独占模式获取
     */
    public final boolean tryAcquireNanos(int arg, long nanosTimeout)
            throws InterruptedException {
        //入口判断线程是否中断
        if (Thread.interrupted())
            throw new InterruptedException();
        // 尝试获取，如果失败，则在acquire loop中进行尝试获取
        return tryAcquire(arg) ||
            doAcquireNanos(arg, nanosTimeout);
    }
```

与可中断获取的acquire loop 对比多了对于时间的判断逻辑

1. 计算deadline，用于判断指定时间
2. 每次park前比较dealine是否已经达到
    -  已经达到超时时间则直接返回false
3. 如果线程需要挂起，判断剩余时间是否达到自旋阈值
    - 剩余时间 > 自旋阈值 ，则park 剩余时间
    - 剩余时间<=自旋阈值，则不park，在acquire loop 中自旋直到超时

```java

    /**
     * 独占超时模式获取
     */
    private boolean doAcquireNanos(int arg, long nanosTimeout)
            throws InterruptedException {
        // 已经超时
        if (nanosTimeout <= 0L)
            return false;
        // 计算deadline
        final long deadline = System.nanoTime() + nanosTimeout;
        final Node node = addWaiter(Node.EXCLUSIVE);
        boolean failed = true;
        try {
            for (;;) {
                final Node p = node.predecessor();
                if (p == head && tryAcquire(arg)) {
                    setHead(node);
                    p.next = null; // help GC
                    failed = false;
                    return true;
                }
                //计算剩余时间
                nanosTimeout = deadline - System.nanoTime();
                if (nanosTimeout <= 0L)
                    // 超时直接返回
                    return false;
                if (shouldParkAfterFailedAcquire(p, node) &&
                        // 判断剩余超时时间是否大于自旋阈值，用于自旋或挂起
                    nanosTimeout > spinForTimeoutThreshold)
                    // 线程挂起到剩余时间
                    LockSupport.parkNanos(this, nanosTimeout);
                if (Thread.interrupted())
                    // 检测到中断直接抛出异常
                    throw new InterruptedException();
            }
        } finally {
            if (failed)
                cancelAcquire(node);
        }
    }

```

自旋判断逻辑: 剩余时间非常短是没有必要进行park，直接进行自旋

```java
    /**
     * The number of nanoseconds for which it is faster to spin
     * rather than to use timed park. A rough estimate suffices
     * to improve responsiveness with very short timeouts.
     */
    static final long spinForTimeoutThreshold = 1000L;
```

