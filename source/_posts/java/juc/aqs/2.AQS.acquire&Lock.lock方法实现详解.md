---
title: 2.AQS.acquire&Lock.lock方法实现详解
date: 2025-08-14 07:02:07
tags:
- java
- juc

category:
- java
- juc
- aqs

---

# AQS 方法实现
根据上述方法介绍，我们自定义实现一个Lock类Reentrant

ReentrantLock 实现简略版本，从这里可以看出：

Lock：面向使用者，接口定义简单易用，隐藏实现细节

AQS：面向同步器开发者，简化了同步器实现步骤，屏蔽了底层同步状态管理，线程队列，等待、唤醒等操作



**Lock实现核心API分析：**

| | 加锁 | 解锁 |
| --- | --- | --- |
| 面向用户 | lock | unlock |
| AQS核心模板方法 | acquire | release |
| 自定义同步器实现方法 | truAcquire | tryRelease |


Lock简单实现源码

```java

public class MyLock implements Lock {
    /**
     * 聚合AQS同步器实现
     */
    private Sync sync = new Sync();

    /**
     * 自定义AQS同步器实现类
     */
    static class Sync extends AbstractQueuedSynchronizer {

        @Override
        protected boolean tryAcquire(int acquires) {
            //获取同步状态
            int state = getState();
            //判断同步器无其他线程占用
            if (state == 0) {
                //cas设置共享状态，不阻塞，返回设置结果
                if (compareAndSetState(0, acquires)) {
                    //获取成功，将当前线程设置为独占线程
                    setExclusiveOwnerThread(Thread.currentThread());
                    return true;
                }
            }
            //当前同步器被占用，判断独占线程是否为当前线程
            else if (isHeldExclusively()) {
                int nextc = state + acquires;
                if (nextc < 0) // overflow
                    throw new Error("Maximum lock count exceeded");
                //独占同步器时其他线程无法操作同步状态，没有并发问题
                //直接设置state+acquires
                setState(nextc);
                return true;
            }
            // 尝试获取失败
            return false;
        }

        @Override
        protected boolean tryRelease(int arg) {
            //目标同步状态
            int state = getState() - arg;
            //是否完全释放同步器
            boolean free = false;
            //判断调用线程是否为独占线程
            if (!isHeldExclusively()) {
                //不独占同步器的线程不能操作释放操作
                throw new IllegalMonitorStateException();
            }
            //同步状态为0，完全释放同步器器
            if (state == 0) {
                // 完全释放标志为true
                free = true;
                //去除独占线程
                setExclusiveOwnerThread(null);
            }
            //独占同步器时其他线程无法操作同步状态，没有并发问题，直接设置state
            setState(state);
            //返回是否完全释放同步状态
            return free;
        }

        @Override
        protected boolean isHeldExclusively() {
            //是否独占同步状态
            return getExclusiveOwnerThread() == Thread.currentThread();
        }
    }

    @Override
    public void lock() {
        //AQS模板方法：同步器阻塞获取同步状态
        sync.acquire(1);
    }

    @Override
    public void lockInterruptibly() throws InterruptedException {
        //AQS模板方法：同步器可中断获取
        sync.acquireInterruptibly(1);
    }

    @Override
    public boolean tryLock() {
        //自定义尝试获取同步状态方法
        return sync.tryAcquire(1);
    }

    @Override
    public boolean tryLock(long time, TimeUnit unit) throws InterruptedException {
        //AQS模板方法：同步器超时可中断获取
        return sync.tryAcquireNanos(1, unit.toNanos(time));
    }

    @Override
    public void unlock() {
        //AQS模板方法：释放同步状态
        sync.release(1);
    }

    @Override
    public Condition newCondition() {
        // 创建条件对象，用于条件等待
        return sync.new ConditionObject();
    }

}
```



## 独占式获取同步状态
### Lock.lock
从Lock.lock来看,调用AQS.acquire方法来实现

```java
    public void lock() {
        //AQS模板方法：同步器阻塞获取同步状态
        sync.acquire(1);
    }
```

### AQS acquire
进入AQS的acquire方法来看：

从这里可以看出acquire模板方法的实现逻辑：

1. 首先尝试获取（子类实现tryAcquire），如果成功则返回
2. 尝试获取失败后
+ 将线程node造节点加入等待队列尾部
+ 从已经入队的节点执行获取

```java
    public final void acquire(int arg) {
        // 首先调用子类实现的尝试获取方法，如果失败则进入队列等待获取
        if (!tryAcquire(arg) &&
            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
            selfInterrupt();
    }
```



### AQS addWaiter
从`addWaiter`和`enq`可以看出，addWaiter为快速一次尝试，尝试失败则进入enq 循环操作直到成功  

加入到等待队列的操作主要可以分为：

1. 使用当前线程构造指定模式（shared、exclusive）node
2. 确保队列已经初始化
+ 未初始化则使用空node（虚节点、哨兵节点）初始化head和tail
3. 将node节点加入到队列尾部
+ 首先将node的prev指向tail
+ cas原子操作将tail指针指向node节点
+ 成功后将原始tail的next指向node



```java
        private Node addWaiter(Node mode) {
        // 获取当前线程，构造不同类型的node节点
        Node node = new Node(Thread.currentThread(), mode);
        // Try the fast path of enq; backup to full enq on failure
        // 尝试直接将node设置为同步队列tail尾部节点，失败后调用全量enq方法
        Node pred = tail;
        //tail存在，队列已经初始化
        if (pred != null) {
            // 先设置 node 的 prev前驱为 tail
            node.prev = pred;
            // cas 尝试设置 tail 为当前 node
            if (compareAndSetTail(pred, node)) {
                // 设置成功后 将 tail的next后继指向 node
                pred.next = node;
                return node;
            }
        }
        // 设置失败，进入full enq方法
        enq(node);
        // 返回node
        return node;
    }

    private Node enq(final Node node) {
        // 循环执行
        for (;;) {
            Node t = tail;
            if (t == null) { // Must initialize
                //如果队列尚未初始化，使用空node初始化head和tail
                if (compareAndSetHead(new Node()))
                    tail = head;
            } else {
                // 和 addWaiter 的 快速 enq 方法类似，在for循环中尝试执行直到成功
                node.prev = t;
                if (compareAndSetTail(t, node)) {
                    t.next = node;
                    // 返回 node 的 prev前驱
                    return t;
                }
            }
        }
    }
```



### AQS acquireQueued
`acquireQueued`用户exclusive和uninterruptible的获取，主要是在loop循环中进行tryAcquire和park

acquire loop 主要逻辑：

1. 获取node的pred
2. 如果pred为head 并且 tryAquire 成功
+ 则设置node为head，标记获取成功，返回中断标志
3. pred不是head 或 tryAcquire 失败
+ 则判断是否应该park，如果需要park，则进行park（被阻塞条件：前驱节点的waitStatus为SIGNAL）
+ 对中断标志进行赋值



```java

    /**
     * Acquires in exclusive uninterruptible mode for thread already in
     * queue. Used by condition wait methods as well as acquire.
     * 用于已经在队列中的线程执行独占不可中断的获取
     */
    final boolean acquireQueued(final Node node, int arg) {
        //失败标志
        boolean failed = true;
        try {
            // 中断标志，是否被中断
            boolean interrupted = false;
            for (;;) { // acquire loop
                //获取node的前驱node
                final Node p = node.predecessor();
                // 如果前驱为head，则尝试获取
                if (p == head && tryAcquire(arg)) {
                    //获取成功
                    setHead(node);
                    // head的next指针置空
                    p.next = null; // help GC
                    failed = false;
                    //返回中断标识
                    return interrupted;
                }
                // node不是head的下一个 或 尝试获取失败，
                // 则根据prev和node的状态判断是否可以阻塞等待，然后执行阻塞
                if (shouldParkAfterFailedAcquire(p, node) &&
                    parkAndCheckInterrupt())
                    interrupted = true;
            }
        } finally {
            // 如果最终获取失败
            if (failed)
                // 则取消节点
                cancelAcquire(node);
        }
    }

```

### setHead、selfInterrupt、parkAndCheckInterrupt
便捷方法：

setHead：<font style="color:rgb(51, 51, 51);background-color:rgb(253, 253, 253);">setHead方法是把当前节点置为虚节点，但并没有修改waitStatus，因为它是一直需要用的数据</font>

```java
    /**
     * 将bode设置为head，实现出队操作
     * 将未使用的字段设置为空，方便GC以及避免不必要的遍历
     *
     */
    private void setHead(Node node) {
        // head 指向 node
        head = node;
        // 释放线程
        node.thread = null;
        // node的prev即指向head的指针置空
        node.prev = null;
    }

    /**
     * Convenience method to interrupt current thread.
     * 
     * 便捷方法 interrupt 当前线程
     */
    static void selfInterrupt() {
        Thread.currentThread().interrupt();
    }

    /**
     * Convenience method to park and then check if interrupted
     *
     * 便捷方法暂停并且检查是否中断
     */
    private final boolean parkAndCheckInterrupt() {
        // 将当前线程进行block
        // 从park中返回的条件：
        // 1. 其他线程对当前线程调用unpark方法
        // 2. 其他线程interrupts 当前线程
        // 3. 没有任何原因的虚假唤醒
        // 因此外层需要重新检查线程的运行条件
        // 一般的范式为：while 中判循环断 执行park，满足条件后跳出循环
        LockSupport.park(this);
        // 清理中断标志，并且返回线程是否中断
        return Thread.interrupted();
    }
```

### AQS shouldParkAfterFailedAcquire
判断是否应该park，是acquire loop 中的主要信号控制

1. 如果pred的status为SIGNAL，pred释放后通知node，node可安全park
2. 如果pred已经cancelled，则node一直向前寻找第一个node不为cancelled的node，链接到该node后，把取消节点从队列中剔除
3. 最后，此时pred的status可能为：0或PROPAGATE，cas尝试修改为SIGNAL，但是不park，再次返回acquire loop中retry，

```java

    /**
     * Checks and updates status for a node that failed to acquire.
     * Returns true if thread should block. This is the main signal
     * control in all acquire loops.  Requires that pred == node.prev.
     * 检查并更新 tryAcquire失败的node节点的状态
     * acquire loop中的主要状态控制
     */
    private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) {
        // 查看pred 前驱节点的状态
         int ws = pred.waitStatus;
        if (ws == Node.SIGNAL)
            /*
             * This node has already set status asking a release
             * to signal it, so it can safely park.
             * 如果node已经设置状态要求pred释放后通知它，则可以安全的暂停
             */
            return true;
        if (ws > 0) {
            /*
             * Predecessor was cancelled. Skip over predecessors and
             * indicate retry.
             * 如果prev前驱已经取消，则一直向前寻找到第一个状态不是取消的node并链接到该非取消node的后面，把取消节点从队列中剔除
             */
            do {
                // 将node 的 prev 指针指向 prev的prev
                node.prev = pred = pred.prev;
                //判断前驱是否已经取消
            } while (pred.waitStatus > 0);
            pred.next = node;
        } else {
            /*
             * waitStatus must be 0 or PROPAGATE.  Indicate that we
             * need a signal, but don't park yet.  Caller will need to
             * retry to make sure it cannot acquire before parking.
             * 此时prev的状态必定时0或传播。
             * 将状态修改为SIGNAL，表明我们需要通知信号，
             * 不过仍然不在暂停，调用在acquire loop中再次尝试获取
             */
            compareAndSetWaitStatus(pred, ws, Node.SIGNAL);
        }
        return false;
    }
```



### cancelAcquire
取消尝试获取的node

1. 清除关联线程
2. 跳过cancelled已经取消的前驱node。找到有效前驱pred
3. 清理取消node，整理队列
+ node为tail：则将tial指向有效pred
+ 当前node为head的后继节点：唤醒后继node
+ 不是hear和taill：后续node需要signal，尝试设置有效pred为SIGNAL，并将pred的next指向后继

对应示意图

根据当前节点的位置，考虑以下三种情况：



(1) 当前节点是尾节点。

![](/images/post/java/juc/aqs/aqs详解/取消尝试获取的node-尾节点.png)

(2) 当前节点是Head的后继节点。唤醒后继节点

![](/images/post/java/juc/aqs/aqs详解/取消尝试获取的node-head后继节点.png)

(3) 当前节点不是Head的后继节点，也不是尾节点。

![](/images/post/java/juc/aqs/aqs详解/取消尝试获取的node-中间节点.png)

此时所有操作都只操作了next指针没有操作prev指针

> **<font style="color:rgb(51, 51, 51);background-color:rgb(253, 253, 253);">执行cancelAcquire的时候，当前节点的前置节点可能已经从队列中出去了（其他线程已经执行过Try代码块中的shouldParkAfterFailedAcquire方法了），如果此时修改Prev指针，有可能会导致Prev指向另一个已经移除队列的Node，因此这块变化Prev指针不安全。 shouldParkAfterFailedAcquire方法中，会执行下面的代码，其实就是在处理Prev指针。shouldParkAfterFailedAcquire是获取锁失败的情况下才会执行，进入该方法后，说明共享资源已被获取，当前节点之前的节点都不会出现变化，因此这个时候变更Prev指针比较安全。</font>**
>
> **<font style="color:rgb(51, 51, 51);background-color:rgb(253, 253, 253);"></font>**
>

```java
            do {
                node.prev = pred = pred.prev;
            } while (pred.waitStatus > 0);
```

**<font style="color:rgb(51, 51, 51);background-color:rgb(253, 253, 253);"></font>**

```java

    /**
     * 取消一个尝试获取的node
     *
     */
    private void cancelAcquire(Node node) {
        // node不存在则忽略
        if (node == null)
            return;
        // node关联线程清空
        node.thread = null;

        // 跳过已经取消的前驱
        Node pred = node.prev;
        while (pred.waitStatus > 0)
            node.prev = pred = pred.prev;

        //有效pred前驱的后继节点，后续cas替换next使用
        Node predNext = pred.next;

        // 将状态设置为cancelled,其他节点可以跳过此node
        node.waitStatus = Node.CANCELLED;

        // 如果node为tail，则将node指向有效pred
        if (node == tail && compareAndSetTail(node, pred)) {
            compareAndSetNext(pred, predNext, null);
        } else {
            //如果后继node需要信号，则尝试设置有效前驱的 next
            //成功则后继node将获取到信号，
            //其他情况则唤醒后继node继续处理
            int ws;
            if (pred != head &&
                ((ws = pred.waitStatus) == Node.SIGNAL ||
                 (ws <= 0 && compareAndSetWaitStatus(pred, ws, Node.SIGNAL))) &&
                pred.thread != null) {
                // 后继节点存在且非取消，设置为有效前驱的next
                Node next = node.next;
                if (next != null && next.waitStatus <= 0)
                    compareAndSetNext(pred, predNext, next);
            } else {
                //条件不满足，则唤醒后继node
                unparkSuccessor(node);
            }
            //node 的 next 指向自己
            node.next = node; // help GC
        }
    }
```

## acquire流程图
了解完整个acquire的代码实现，再看一下acquire的流程图

![](/images/post/java/juc/aqs/aqs详解/acquire流程图.webp)

> 参考链接：
>
> + [从ReentrantLock的实现看AQS的原理及应用](https://tech.meituan.com/2019/12/05/aqs-theory-and-apply.html)
> + [万字超强图文讲解AQS以及ReentrantLock应用](https://mp.weixin.qq.com/s/msZXjpuT74EJ_gDY5DSOCQ)
>



