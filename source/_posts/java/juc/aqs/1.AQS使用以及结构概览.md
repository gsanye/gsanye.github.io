---
title: 1.AQS使用以及结构概览
date: 2025-08-13 07:02:07
tags:
- java
- juc

category:
- java
- juc
- aqs

---

# JUC Lock 和 synchronized对比
## ReentryLock 和 synchronized 对比概览
| | ReentrantLock | synchronized |
| --- | --- | --- |
| 锁实现机制 | **依赖AQS** | **监视器模式** |
| 释放形式 | **必须显示调用unlock()释放锁** | 自动释放监视器 |
| 锁类型 | **公平锁**、非公平锁 | 非公平锁 |
| 可重入性 | 可重入 | 可重入 |
| 条件队列 | 可关联多个条件队列 | 仅能关联一个条件队列 |
| 灵活性 | + 响应中断：lockInterruptibly()<br/>+ 超时获取：<font style="color:rgb(63, 63, 63);">tryLock(long time, timeUnit)</font><br/>+ <font style="color:rgb(63, 63, 63);">非阻塞尝试获取：tryLock()</font> | 阻塞式、不能响应中断、不可超时，不灵活 |


## 使用方式样例说明
### ReentrantLock使用方式：
```java
    private void lockDemo(){
        Lock lock = new ReentrantLock();
        lock.lock();//block until hold lock
        try{
            //method body...
        }finally{
            lock.unlock(); // must in finally unlock
        }
    }
```



### synchronized
```java

public class SynchronizationTest {
    /**
     * 同步静态方法，synchronized 监视器为 所在class对象
     */
    public synchronized static void lockStatic(){
        //method body...
    }

    /**
     * 同步实例方法，synchronized 监视器为 this实例对象
     */
    public synchronized void lock(){
        // method body
    }
    
    private final Object lock = new Object();

    /**
     * 同步代码块，synchronized 监视器为 指定lock对象
     */
    public void lockBlock(){
        synchronized(lock){
            //block
        }
    }
}

```



## ReentrantLock 和 AQS 组合以及方法概览
### Lock接口定义
从接口定义中可以看出JUC Lock 方法比synchronized锁的使用上，有更多灵活选择

```java
public interface Lock {

    void lock();

    void lockInterruptibly() throws InterruptedException;

    boolean tryLock();

    boolean tryLock(long time, TimeUnit unit) throws InterruptedException;

    void unlock();

    Condition newCondition();
}

```



### ReentrantLock 聚合 AQS实现
ReentrantLock 内部成员变量：`Sync sync`同步器继承AbstractQueuedSynchronizer，通过AQS模板方法，实现Lock接口功能



```java
public class ReentrantLock implements Lock, java.io.Serializable {

    /**
    * 内部组合 队列同步器实现，作为锁的底层实现
    * 避免直接继承AQS，灵活性，且屏蔽底层实现对外暴露
    */
    private final Sync sync;

    /**
     * 同步器实现
     */
    abstract static class Sync extends AbstractQueuedSynchronizer {
        
    }

    /**
     *非公平-同步器
     */
    static final class NonfairSync extends Sync {
        
    }

    /**
     * 公平-同步器
     */
    static final class FairSync extends Sync {
        
    }
}
```



从此可以分析得出ReentrantLock和AQS的组合示意图如下：



![](/images/post/java/juc/aqs/aqs详解/ReentrantLock和AQS的组合示意图.webp)

# AQS 结构以及方法分析
## AQS队列结构
### AQS属性说明
AbstractQueuedSynchronizer 是一个抽象类，很多方法定义为`final`模板方法，一些方法定义为`abstract`抽象方法，由子类选择实现，由此提供不能能力

1. AQS内部成员变量 Node类型的：`head``tail`头尾节点指针，用户记录队列的首尾node对象引用
2. AQS等待队列(同步队列 & 条件队列 )为 `"CLH" `队列变体的虚拟双向队列（FIFO），用于阻塞和队列线程对同步状态的操作
3. int类型 `state`状态字段，记录同步器临界资源的状态数据
4. 所有属性均有`**volatile**`关键字修饰，保证多线中的可见性

```java
public abstract class AbstractQueuedSynchronizer
    extends AbstractOwnableSynchronizer
    implements java.io.Serializable {

    /**
     * 头节点
     */
    private transient volatile Node head;

    /**
     * 尾部节点
     */
    private transient volatile Node tail;

    /**
     * 同步器状态
     */
    private volatile int state;
```

### 同步队列示意图：
![](/images/post/java/juc/aqs/aqs详解/同步队列示意图.webp)



## Node节点
### Node节点属性说明
内部类Node节点为对列中的每一个节点对象

1. Node类型的：`prev`前驱节点指针、`next`后继节点指针、`nextWaiter`节点处于条件队列时的后继节点指针，用于构成双向队列
2. int 类型的 `waitStatus`等待状态，记录节点的状态，可能时值为：-3、-2、-1、0、1
3. Thread类型的`thread`对象，为此Node对应的线程对象，用于阻塞和唤醒
4. nextWaiter 在获取所同步状态后才能进去条件等待队列，因此不涉及多线程操作，没有使用 `volatile`关键字修饰
5. 其他字段属性均有`**volatile**`关键字修饰，保证多线中的可见性

```java
    static final class Node {

        volatile int waitStatus;

        volatile Node prev;

        volatile Node next;

        volatile Thread thread;

        Node nextWaiter;

    }
```

| 方法和属性值 | 含义 |
| --- | --- |
| waitStatus | 当前节点在队列中的状态 |
| thread | 表示处于该节点的线程 |
| prev | 前驱指针 |
| next | 后继指针 |
| nextWaiter | 指向下一个处于CONDITION状态的节点（Condition Queue队列） |


### Node节点状态说明
| waitStatus枚举 | 状态说明 |
| --- | --- |
|  CANCELLED =  1 | 由于超时或中断，线程取消获取请求，节点状态不会再变化 |
| SIGNAL    = -1 | 后继node线程需要唤醒 |
| CONDITION = -2 | 节点在等待队列中，等待被唤醒 |
| PROPAGATE = -3 | 当前线程处在SHARED情况下，指示sh<font style="background-color:#FBF5CB;"></font>are共享状态获取应该传播 |
| 0 | 初始化默认值，方便程序状态判断 |




### Node节点示意图
![](/images/post/java/juc/aqs/aqs详解/AQS使用以及结构概览.webp)



## 方法分析
### 同步状态state操作方法
队列状态获取和操作方法为`protected final`，不对外暴露部，子类可以直接使用，禁止子类重写

| **<font style="color:rgb(255, 255, 255);">方法名</font>** | **<font style="color:rgb(255, 255, 255);">描述</font>** |
| :--- | --- |
| <font style="color:rgb(34, 34, 34);">protected final int getState()</font> | <font style="color:rgb(34, 34, 34);">获取State的值</font> |
| <font style="color:rgb(34, 34, 34);">protected final void setState(int newState)</font> | <font style="color:rgb(34, 34, 34);">设置State的值</font> |
| <font style="color:rgb(34, 34, 34);background-color:#FBDE28;">protected final boolean compareAndSetState(int expect, int update)</font> | <font style="color:rgb(34, 34, 34);">使用CAS方式更新State，原子更新，成功或失败</font> |


同步组件或者锁可以分为

+ 独占式
+ 共享式

独占式和共享式组件的同步状态区别也很明显：

独占式 ：state 0--1

共享式： state 0--N

![](/images/post/java/juc/aqs/aqs详解/独占式和共享式组件的同步状态区别.webp)

### AQS模板方法
模板方法为`public final`定义编排好模板方法流程，外部可以直接调用，禁止子类重写。此处的模板方法也分为两类：独占式、共享式

+ acquire 获取同步状态，和响应中断以及超时的版本
+ 释放同步状态

| 方法名 | 描述 |
| --- | --- |
| void acquire(int arg) | <font style="background-color:#FBDE28;">独占式</font>获取同步状态，获取成功则返回，获取失败则进入同步队列，阻塞式（park()）等待，直到获取到锁 |
|  void acquireInterruptibly(int arg) | 可中断获取同步状态，同acquire方法，不过可以响应中断，如果线程在获取同步状态时（获取前或队列中等待时）被中断，则取消获取同步状态，抛出InterruptedException |
| boolean tryAcquireNanos(int arg, long nanosTimeout) | 在acquireInterruptibly基础上，增加超时功能，如果在指定时间获取到同步状态，则返回true，否则返回false |
| boolean release(int arg) | <font style="background-color:#FBDE28;">独占式</font>释放同步状态 |
| void acquireShared(int arg) | <font style="background-color:#FBDE28;">共享式</font>获取同步状态，与acquire的区别是，同一时刻可以有多个线程获取到同步状态 |
| void acquireSharedInterruptibly(int arg) | 与acquireShared相同，支持响应中断 |
| boolean tryAcquireSharedNanos(int arg, long nanosTimeout) | 与acquireInteruptibly相同，支持超时返回 |
| boolean releaseShared(int arg) | <font style="background-color:#FBDE28;">共享式</font>释放同步状态 |


### 同步器组件重写方法
同步器组件也可以根据独占式和共享式的分类方式，选择重写的方法类型，AQS中需要重写的方法使用异常的方式作为默认实现，避免子类重写不需要的方法

```java
    protected boolean tryAcquire(int arg) {
        throw new UnsupportedOperationException();
    }
```



| 方法名 | 描述 |
| --- | --- |
|  boolean tryAcquire(int arg) | 独占式获取同步状态<br/>获取成功则返回true，否则返回false |
| boolean tryRelease(int arg) | 独占式释放同步状态<br/>完全释放则返回true，否则返回false |
| boolean isHeldExclusively() | 该线程是否正在独占资源，使用Condition时实现此方法 |
| int tryAcquireShared(int arg) | 共享式获取同步状态<br/>返回值 < 0 获取失败<br/>返回值 = 0 获取成功，且无剩余资源<br/>返回值 > 0 获取成功，且有剩余资源，其他线程可继续获取 |
| boolean tryReleaseShared(int arg) | 共享式释放同步状态，<br/>如果释放后允许后续线程获取（shared、exclusive）则返回true<br/>否则返回false |


# 
