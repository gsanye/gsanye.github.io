
---
title: 3.AQS.release & Lock.unlock 方法实现详解
date: 2025-08-14 07:08:07
tags:
- java
- juc

category:
- java
- juc
- aqs

---

# 独占式释放同步状态
## ReentranLock的unlock方法
1. 通过调用AQS的release方法实现解锁

```java
    public void unlock() {
        //AQS模板方法：释放同步状态
        sync.release(1);
    }
```



## 通过调用AQS的release模板方法完成同步状态释放
1. 调用子类实现tryRelase释放同步状态
2. 如果同步状态完全释放
+ 判断head存在且状态为非初始化
+ 唤醒后继node

判断是否唤醒node时候的判断条件：

<font style="color:rgb(51, 51, 51);background-color:rgb(253, 253, 253);">这里的判断条件为什么是h != null && h.waitStatus != 0？</font>

> 1. **<font style="color:rgb(51, 51, 51);background-color:rgb(253, 253, 253);">h == null Head还没初始化。初始情况下，head == null，第一个节点入队，Head会被初始化一个虚拟节点。所以说，这里如果还没来得及入队，就会出现head == null 的情况。</font>**
> 2. **<font style="color:rgb(51, 51, 51);background-color:rgb(253, 253, 253);">h != null && waitStatus == 0 表明后继节点对应的线程仍在运行中，不需要唤醒。</font>**
> 3. **<font style="color:rgb(51, 51, 51);background-color:rgb(253, 253, 253);">h != null && waitStatus < 0 表明后继节点可能被阻塞了，需要唤醒。</font>**
>



```java

    /**
     * 独占模式释放，如果tryRelease放回true，解除后继节点阻塞（唤醒后继节点）
     */
    public final boolean release(int arg) {
        //尝试释放同步状态
        if (tryRelease(arg)) {// 如果同步状态完全释放
            Node h = head;
            // 查看head（此线程对应的node即为head）状态
            if (h != null && h.waitStatus != 0)
                //唤醒通知后继几点
                unparkSuccessor(h);
            return true;
        }
        return false;
    }
```

## Lock的Sync同步器实现的tryRelease方法
1. 首先判断线程是否获取了同步状态，为当前独占线程
+ 不是独占线程不允许执行释放操作，抛出 IllegalMonitorStateException
2. 根据是否后的同步状态判断是否完全释放
+ 已经完全释放同步状态后：清理独占线程、标记完全释放
3. 设置同步状态

```java

        @Override
        protected boolean tryRelease(int arg) {
            //目标同步状态
            int state = getState() - arg;
            //是否完全释放同步器
            boolean free = false;
            //判断调用线程是否为独占线程
            if (getExclusiveOwnerThread() != Thread.currentThread()) {
                //不独占同步器的线程不能操作释放操作
                throw new IllegalMonitorStateException();
            }
            //同步状态为0，完全释放同步器器
            if (state == 0) {
                // 完全释放标志为true
                free = true;
                //去除独占线程
                setExclusiveOwnerThread(null);
            }
            //独占同步器时其他线程无法操作同步状态，没有并发问题，直接设置state
            setState(state);
            //返回是否完全释放同步状态
            return free;
        }

```

## 再看如何unparSuccessor取消后继节点的挂起
1. 获取node的状态
+ 如果节点状态为signal，清理状态为初始化，准备发送通知
2. 获取后继节点
+ 如果后继节点为取消，则从tail向前遍历，找到队列中第一个为非cancelled的node
3. 唤醒后继节点

```java

    /**
     * 唤醒后继节点
     */
    private void unparkSuccessor(Node node) {
        // 获取head状态
        int ws = node.waitStatus;
        // 如果head 状态 <0 即需要signal
        if (ws < 0)
            // 清理signal状态，准备发送信号（唤醒后继node），
            // 设置状态为0初始化（尝试更新，失败也无影响）
            compareAndSetWaitStatus(node, ws, 0);

        // 获取后继node
        Node s = node.next;
        //如果后继node为null或者已经cancelled
        if (s == null || s.waitStatus > 0) {
            s = null;
            //从tail向前遍历找，找到队列头部第一个非cancelled node
            for (Node t = tail; t != null && t != node; t = t.prev)
                if (t.waitStatus <= 0)
                    s = t;
        }
        if (s != null)
            // 唤醒非cancelled node
            LockSupport.unpark(s.thread);
    }
```

为什么查询非取消节点要从后向前遍历

1. 节点入队时先操作prev指针，再操作next指针，非原子方法
+ <font style="color:rgb(51, 51, 51);background-color:rgb(253, 253, 253);">node.prev = pred; compareAndSetTail(pred, node) 这两个地方可以看作Tail入队的原子操作，但是此时pred.next = node;还没执行</font>    

```java
private Node addWaiter(Node mode) {
	Node node = new Node(Thread.currentThread(), mode);
	// Try the fast path of enq; backup to full enq on failure
	Node pred = tail;
	if (pred != null) {
		node.prev = pred;
		if (compareAndSetTail(pred, node)) {
			pred.next = node;
			return node;
		}
	}
	enq(node);
	return node;
}
```

2. 节点取消时，先修改prev指针,再修改next指针，所以要从后使用prev指针进行便利

```java

        // Skip cancelled predecessors
        Node pred = node.prev;
        while (pred.waitStatus > 0)
            node.prev = pred = pred.prev;

            // 省略代码......
            compareAndSetNext(pred, predNext, null);
            // 省略代码......
            node.next = node; // help GC
        

```

# 取消挂起后继续执行
节点从挂起处被唤醒，继续执行，清理并返回是否被中断

```java
    private final boolean parkAndCheckInterrupt() {
        LockSupport.park(this);
        return Thread.interrupted();
    }
```

返回到acquireQueued方法，继续acquire loop,记录中断标志，在循环当中tryAcqire

```java
    final boolean acquireQueued(final Node node, int arg) {
        boolean failed = true;
        try {
            boolean interrupted = false;
            for (;;) {
                final Node p = node.predecessor();
                if (p == head && tryAcquire(arg)) {
                    setHead(node);
                    p.next = null; // help GC
                    failed = false;
                    return interrupted;
                }
                if (shouldParkAfterFailedAcquire(p, node) &&
                    parkAndCheckInterrupt())
                    interrupted = true;
            }
        } finally {
            if (failed)
                cancelAcquire(node);
        }
    }
```

获取同步状态成功后，将node设置为head，返回中断标志

```java
    public final void acquire(int arg) {
        if (!tryAcquire(arg) &&
            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
            selfInterrupt();
    }
```

如果获取过过程被其他线程中断过，由于在acquire loop 中清理了中断标志，此处进行中断标志的设置，恢复当前线程中断状态

```java
    /**
     * Convenience method to interrupt current thread.
     */
    static void selfInterrupt() {
        Thread.currentThread().interrupt();
    }
```

至此，锁的获取和释放逻辑已经完全讲解结束

