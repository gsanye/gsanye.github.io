---
title: 两数之和
date: 2025-08-23 07:02:07
tags:
- algorithm
- array

category:
- algorithm
- leetcode

---

## 题目要求
给定一个数组，和一个目标值，要求在数组中找到两个数值和为目标值，返回两个数值的数组下标

## 题目解析
### 穷举（暴力枚举）
从题目要求很容易想到，我们可以使用双层遍历，为每一个数组元素向后匹配剩余元素，是否满足和为目标值的要求,满足要求则返回对应数组角标

```java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        int length = nums.length;
        for (int i = 0; i < length; i++) {
            int searchFor = target - nums[i];
            for (int j = i+1; j < length; j++) {
                if (nums[j] == searchFor){
                    return new int[]{i,j};
                }
            }
        }
        return null;
    }
}
```

#### 复杂度分析
+ 时间复杂度  
双层遍历，外层遍历从0-n，内层遍历从j-n，  
复杂度计算：n + (n-1) + (n-2) + ... + 1 + 0 = (n*n)/2   
根据大O时间复杂度分析，**去除常量、低阶、系数**最终的时间复杂度为$O(n^2)$
+ 空间复杂度  
由于没有使用到新的数据存储，所以空间复杂度为 O(1)

### Hash表
题目中的要求是寻求两数之和等于目标值，我们很容易想到依次遍历每一个元素，寻找剩余元素中是否存在searchFor的值，这里由于是value是int，且数组角标也是int，其实我们可以尝试使用**空间换时间**的方法。  
在寻找searchFor的过程中我们可以一个个的遍历，但是时间复杂度较高，如果有一种方法可以直接告诉我们是否存在这个searchFor的元素并返回对应的数组角标那么就可以省去内层遍历的步骤。

这时候我们想到的数据结构是Hash，**Hash可以直接根据我们给定的Key，返回对应的value，时间复杂度是O(1).**  
这种解题思路相当于创建了一个索引，后续遍历直接使用索引减少遍历的次数，后续解题过程中可以参考这种思路

```java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        int length = nums.length;
        Map<Integer, Integer> map = new HashMap<>(length);
        for (int i = 0; i < length; i++) {
            // get 和 比较 时存在类型包装和解包
            map.put(nums[i], i);
        }
        for (int i = 0; i < length; i++) {
            int searchFor = target - nums[i];
            Integer searchForIndex = map.get(searchFor);
            if (searchForIndex != null && searchForIndex != i) {
                return new int[]{i, searchForIndex};
            }
        }
        return null;
    }
}

```

#### Hash表优化
最简单的Hash表解法中遍历了两遍nums数组，第一遍为预制Hash表，第二遍为寻找searchFor，这里存在可以优化的点，即只遍历一遍nums，原理为第一次寻找Map中是否存在searchFor，如果不存在，则将此时的数据填充Hash表，继续向后遍历

**这时的逻辑变为了从此index的值查找前面是否存在满足条件的searchFor，类似于反向搜索并且逐步填充Hash表**，当然复杂度未变化

```java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        int length = nums.length;
        Map<Integer, Integer> map = new HashMap<>(length);
        for (int i = 0; i < length; i++) {
            int searchFor = target - nums[i];
            Integer searchForIndex = map.get(searchFor);
            if (searchForIndex != null) {
                return new int[]{searchForIndex, i};
            }
            map.put(nums[i], i);
        }
        return null;
    }
}
```

#### 复杂度分析
+ 时间复杂度分析：  
单层遍历：O(n)
+ 空间复杂度分析：  
和数组nums相同的O(n)

